# 模版实例化
1.用具体型别替代模版参数T的过程叫做实例化，从而产生一个模版实例。
2.一旦使用函数模版，编译器会自动触发，不需要额外请求模版实例化
3.如果实例化一种型别，该型别内部并不支持函数所使用的操作没那么会导致编译错误，
例如std::complex并没有重载">",也就是说该型别并不支持">"来比大小，而Max函数使用">"来判断大小就无法使用Max（c1,c2）来的得到结果。

结论：模版被编译了两次
1.没有实例化之前检查模版代码本身是否有语法错误。
2.实例化期间，检查模版代码的调用是否合法。

# 参数推导
1.模版参数是有传递给模版参数的实参决定的
2.不允许自动型别转换：每个T必须严格匹配
Max(1,2) //ok
Max(1, 2.0) //error

处理方法：
1、用static_cast或强制转换参数类别
Max(static_cast<double>(1), 2.0)
2、显式指定T的型别
Max<double>(1, 2.0)

# 函数模版重载
1.函数模版也可以像普通函数一样被重载
2.非模版函数可以和同名的函数模版共存
3.编译器通过函数模版参数推断使用哪个函数
4.当重载函数模版是，将改变限制在：显式指定模版参数
5.所用的重载版本的声明必须位于他们被调用的位置之前